import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFSheet;

import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.Date;
import java.util.*;
import java.util.stream.Collectors;

public class LargeExcelWriter {

    // Configuration constants
    private static final int WINDOW_SIZE = 100; // Rows to keep in memory
    private static final int FLUSH_INTERVAL = 50; // Rows to process before flushing
    private static final int MAX_COLUMN_WIDTH = 100; // Max column width in characters

    public static <T> void writeLargeDataset(List<T> objects, String filePath) throws IOException {
        // Validate inputs
        if (objects == null || objects.isEmpty()) {
            throw new IllegalArgumentException("Object list cannot be null or empty");
        }
        if (filePath == null || !filePath.toLowerCase().endsWith(".xlsx")) {
            throw new IllegalArgumentException("File path must end with .xlsx extension");
        }

        // Create workbook with row access window
        try (SXSSFWorkbook workbook = new SXSSFWorkbook(WINDOW_SIZE)) {
            workbook.setCompressTempFiles(true); // Compress temporary files
            
            SXSSFSheet sheet = workbook.createSheet("Data");
            sheet.setRandomAccessWindowSize(WINDOW_SIZE);

            // Get ordered fields
            List<Field> orderedFields = getOrderedFields(objects.get(0).getClass());

            // Create styles
            Map<Class<?>, CellStyle> styleMap = createStyleMap(workbook);

            // Create header row
            createHeaderRow(sheet, orderedFields, styleMap.get(String.class));

            // Write data rows
            writeDataRows(sheet, objects, orderedFields, styleMap);

            // Auto-size columns
            autoSizeColumns(sheet, orderedFields.size());

            // Write to file
            writeWorkbook(workbook, filePath);
            
            // Clean up temporary files
            workbook.dispose();
        }
    }

    private static List<Field> getOrderedFields(Class<?> clazz) {
        return Arrays.stream(clazz.getDeclaredFields())
                .filter(f -> f.isAnnotationPresent(ExcelColumn.class))
                .sorted(Comparator.comparingInt(f -> f.getAnnotation(ExcelColumn.class).order()))
                .collect(Collectors.toList());
    }

    private static Map<Class<?>, CellStyle> createStyleMap(SXSSFWorkbook workbook) {
        Map<Class<?>, CellStyle> styleMap = new HashMap<>();
        
        // Header style
        CellStyle headerStyle = workbook.createCellStyle();
        Font headerFont = workbook.createFont();
        headerFont.setBold(true);
        headerFont.setColor(IndexedColors.WHITE.getIndex());
        headerStyle.setFont(headerFont);
        headerStyle.setFillForegroundColor(IndexedColors.DARK_BLUE.getIndex());
        headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        headerStyle.setAlignment(HorizontalAlignment.CENTER);
        styleMap.put(String.class, headerStyle);

        // Data styles
        styleMap.put(Object.class, createDataStyle(workbook, null, HorizontalAlignment.LEFT));
        
        CellStyle numberStyle = createDataStyle(workbook, null, HorizontalAlignment.RIGHT);
        styleMap.put(Number.class, numberStyle);
        
        CellStyle dateStyle = createDataStyle(workbook, 
            workbook.createDataFormat().getFormat("yyyy-mm-dd"), HorizontalAlignment.LEFT);
        styleMap.put(Date.class, dateStyle);
        
        CellStyle booleanStyle = createDataStyle(workbook, null, HorizontalAlignment.CENTER);
        styleMap.put(Boolean.class, booleanStyle);
        
        return styleMap;
    }

    private static CellStyle createDataStyle(Workbook workbook, Short dataFormat, HorizontalAlignment alignment) {
        CellStyle style = workbook.createCellStyle();
        style.setAlignment(alignment);
        if (dataFormat != null) {
            style.setDataFormat(dataFormat);
        }
        return style;
    }

    private static void createHeaderRow(SXSSFSheet sheet, List<Field> fields, CellStyle style) {
        Row headerRow = sheet.createRow(0);
        for (int i = 0; i < fields.size(); i++) {
            Field field = fields.get(i);
            ExcelColumn annotation = field.getAnnotation(ExcelColumn.class);
            String header = annotation.header().isEmpty() ? field.getName() : annotation.header();
            
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(header);
            cell.setCellStyle(style);
        }
    }

    private static <T> void writeDataRows(SXSSFSheet sheet, List<T> objects, 
            List<Field> fields, Map<Class<?>, CellStyle> styleMap) {
        int rowCount = 0;
        
        for (T obj : objects) {
            Row row = sheet.createRow(++rowCount);
            
            for (int i = 0; i < fields.size(); i++) {
                Field field = fields.get(i);
                try {
                    field.setAccessible(true);
                    Object value = field.get(obj);
                    Cell cell = row.createCell(i);
                    
                    if (value != null) {
                        setCellValue(cell, value, styleMap);
                    }
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Error accessing field value", e);
                }
            }
            
            // Periodically flush to disk
            if (rowCount % FLUSH_INTERVAL == 0) {
                try {
                    sheet.flushRows(FLUSH_INTERVAL);
                } catch (IOException e) {
                    throw new RuntimeException("Error flushing rows", e);
                }
            }
        }
    }

    private static void setCellValue(Cell cell, Object value, Map<Class<?>, CellStyle> styleMap) {
        Class<?> valueType = value.getClass();
        CellStyle style = styleMap.getOrDefault(valueType, 
            styleMap.get(Number.class.isAssignableFrom(valueType) ? Number.class :
            Date.class.isAssignableFrom(valueType) ? Date.class :
            Boolean.class.isAssignableFrom(valueType) ? Boolean.class :
            Object.class));
        
        cell.setCellStyle(style);
        
        if (value instanceof Number) {
            cell.setCellValue(((Number) value).doubleValue());
        } else if (value instanceof Boolean) {
            cell.setCellValue((Boolean) value);
        } else if (value instanceof Date) {
            cell.setCellValue((Date) value);
        } else {
            cell.setCellValue(value.toString());
        }
    }

    private static void autoSizeColumns(SXSSFSheet sheet, int columnCount) {
        for (int i = 0; i < columnCount; i++) {
            sheet.trackColumnForAutoSizing(i);
            sheet.autoSizeColumn(i);
            
            // Limit column width
            int currentWidth = sheet.getColumnWidth(i);
            int maxWidth = MAX_COLUMN_WIDTH * 256; // Convert to Excel units
            if (currentWidth > maxWidth) {
                sheet.setColumnWidth(i, maxWidth);
            }
        }
    }

    private static void writeWorkbook(SXSSFWorkbook workbook, String filePath) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(filePath)) {
            workbook.write(fos);
        }
    }
}
