import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import software.amazon.awssdk.auth.credentials.DefaultAWSCredentialsProviderChain;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.rds.RdsUtilities;
import software.amazon.awssdk.services.rds.model.GenerateAuthenticationTokenRequest;

import javax.sql.DataSource;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

@Configuration
public class DataSourceConfig {

    // === Production (IAM) Configuration ===
    @Profile("prod")
    @Configuration
    public static class ProdDataSourceConfig {
        @Value("${aws.rds.endpoint}")
        private String endpoint;

        @Value("${aws.rds.port}")
        private int port;

        @Value("${aws.rds.dbname}")
        private String dbname;

        @Value("${aws.region}")
        private String region;

        @Value("${aws.rds.iam-user}")
        private String iamUser;

        private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        private volatile HikariDataSource dataSource;

        @PostConstruct
        public void init() {
            refreshDataSource();
            scheduler.scheduleAtFixedRate(this::refreshDataSource, 14, 14, TimeUnit.MINUTES);
        }

        @PreDestroy
        public void destroy() {
            scheduler.shutdown();
            if (dataSource != null) {
                dataSource.close();
            }
        }

        private void refreshDataSource() {
            RdsUtilities rdsUtilities = RdsUtilities.builder()
                    .credentialsProvider(DefaultAWSCredentialsProviderChain.create())
                    .region(Region.of(region))
                    .build();

            String token = rdsUtilities.generateAuthenticationToken(
                    GenerateAuthenticationTokenRequest.builder()
                            .username(iamUser)
                            .hostname(endpoint)
                            .port(port)
                            .build()
            );

            HikariConfig config = new HikariConfig();
            config.setJdbcUrl(String.format("jdbc:postgresql://%s:%d/%s", endpoint, port, dbname));
            config.setUsername(iamUser);
            config.setPassword(token);
            config.setDriverClassName("org.postgresql.Driver");

            if (dataSource != null) {
                dataSource.close();
            }
            dataSource = new HikariDataSource(config);
        }

        @Bean
        public DataSource dataSource() {
            return () -> dataSource.getConnection();
        }
    }

    // === Local Configuration ===
    @Profile("local")
    @Configuration
    public static class LocalDataSourceConfig {
        @Value("${spring.datasource.url}")
        private String jdbcUrl;

        @Value("${spring.datasource.username}")
        private String username;

        @Value("${spring.datasource.password}")
        private String password;

        @Bean
        public DataSource dataSource() {
            HikariConfig config = new HikariConfig();
            config.setJdbcUrl(jdbcUrl);
            config.setUsername(username);
            config.setPassword(password);
            config.setDriverClassName("org.postgresql.Driver");
            return new HikariDataSource(config);
        }
    }
}
